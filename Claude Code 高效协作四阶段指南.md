# Claude Code 高效协作四阶段指南

## 📋 协作流程总览

| 阶段 | 目标 | 沟通要点 | Token消耗 | 核心价值 |
|:---:|:------|:---------|:---------:|:---------|
| **概念层** | 可行性调研 | 只分析不写代码 | ⭐ 极低 | 确认方向正确 |
| **骨架层** | 最小可行性验证 | 允许代码粗糙 | ⭐⭐ 中等 | 验证核心假设 |
| **血肉层** | 完善与规范 | 遵循项目规范 | ⭐⭐⭐ 较高 | 产出高质量代码 |
| **记忆固化** | 记录技术决策 | 写入CLAUDE.md | ⭐ 极低 | 形成长期共识 |

---

## 一、概念层：可行性调研

**目标**：确定需求是否可行，识别技术难点和大致改动范围，**不写实际代码**。

**沟通要求/技巧**：
- 用自然语言清晰描述业务目标
- 要求CC只做分析，不修改代码
- 引导CC指出潜在风险或依赖

**样例指令**：
> “我想给扫雷游戏增加一个计时器：游戏开始计时，结束时停止。请先不要改代码，帮我分析现有代码结构下实现这个功能的难点和大致改动点。”

**样例CC产出**：
- 列出技术难点（如定时器清理、重置处理）
- 指出需要修改的函数（initGame, 游戏结束逻辑）
- 给出粗略实现路径

---

## 二、骨架层：最小可行性验证

**目标**：用最少的代码验证核心假设，确保关键路径能跑通，**允许代码粗糙**。

**沟通要求/技巧**：
- 明确要求只做“最小改动”，强调“能跑通即可”
- 允许在验证后抛弃代码，不要过早优化
- 如果发现问题，及时追加验证（如修正启动时机）

**样例指令**：
> “请在现有代码基础上，只添加实现计时器所需的最少改动：显示计时器，点击第一个格子开始计时，游戏结束停止，重置归零。直接给出修改后的完整文件，代码尽量简单。”

**样例CC产出**：
- 增加全局计时变量和 setInterval 逻辑
- 修改点击监听和游戏结束函数
- 提供一个可运行的 demo，虽然样式简陋但功能符合基本要求

---

## 三、血肉层：完善与规范

**目标**：基于已验证的骨架，按照项目规范完善代码（样式、封装、健壮性、注释）。

**沟通要求/技巧**：
- 给出明确的完善清单（如样式统一、封装成对象、防止内存泄漏）
- 要求遵循项目现有代码风格（缩进、命名等）
- 可要求添加注释解释关键决策

**样例指令**：
> “骨架验证通过！现在请完善计时器：1. 样式与扫雷界面一致；2. 封装到 Timer 对象；3. 确保重置时清除旧定时器；4. 添加必要注释；5. 遵循 2 空格缩进。输出完整 index.html。”

**样例CC产出**：
- 输出结构清晰、封装良好的代码
- 计时器逻辑独立为 Timer 类或对象
- CSS 样式匹配原界面
- 关键逻辑添加注释

---

## 四、记忆固化：记录技术决策

**目标**：将本次开发中确认的规则、技术选型、注意事项写入 `CLAUDE.md`，形成长期共识。

**沟通要求/技巧**：
- 要求 CC 总结本次开发的关键决策和易错点
- 指定写入项目根目录的 `CLAUDE.md`（如不存在则创建）
- 内容应简洁、可操作，供后续开发参考

**样例指令**：
> “请总结我们实现计时器的关键技术决策（启动时机、停止时机、重置处理、封装方式、易错点），并追加到项目根目录的 `CLAUDE.md` 中。”

**样例CC产出**：
在 `CLAUDE.md` 中新增一段结构化记录，如：
```markdown
## 计时器功能实现记录 (2025-02-19)

- **启动时机**：计时器不在游戏初始化时启动，而是在玩家第一次执行“翻开格子”操作（左键点击未翻开且未标记的格子）时启动。这样可以避免在玩家思考时计时器空跑。
- **停止时机**：在游戏结束（点到雷或赢得游戏）以及点击重置按钮时，必须调用 `Timer.stop()` 清除 `setInterval`，防止后台继续计时或内存泄漏。
- **重置处理**：重置时除了停止旧计时器，还应将计时器显示重置为 0，并重置 `gameStarted` 标志，以便下一次点击重新启动。
- **封装**：计时器相关状态和逻辑统一封装在 `Timer` 对象中，通过 `Timer.start()`, `Timer.stop()`, `Timer.reset()` 等接口与主逻辑交互，避免全局变量污染。
- **易错点**：在启动新计时器前，务必先调用 `Timer.stop()` 清除可能存在的旧定时器；在游戏结束判断中，确保所有分支都能调用 `Timer.stop()`。
